name: Rollbar Autofix
description: Automatically opens PRs to fix Rollbar errors.
author: Rollbar
branding:
  icon: zap
  color: blue

inputs:
  openai_api_key:
    description: API key for Codex
    required: true
  rollbar_access_token:
    description: Rollbar project access token (read/write) for MCP tools
    required: true
  github_token:
    description: Token for opening GitHub PR. Use a PAT to enable running workflows. Or leave blank to use GITHUB_TOKEN.
    required: false
    default: ''
  item_counter:
    description: Rollbar item counter (e.g., 123456). If omitted, the action attempts to derive it from the branch name (autofix/rollbar-item-<counter>-*).
    required: false
  review_feedback:
    description: Optional reviewer feedback or instructions to guide the rerun
    required: false
    default: ''
  collect_review_feedback:
    description: When true, auto-collect the full PR conversation (reviews, inline comments, PR comments) and include it if a PR is found.
    required: false
    default: 'true'
  review_feedback_truncate:
    description: Whether to truncate very large PR conversations before injecting into the prompt.
    required: false
    default: 'true'
  review_feedback_max_chars:
    description: Max characters of PR conversation to include when truncation is enabled.
    required: false
    default: '60000'
  environment:
    description: Rollbar environment (e.g., staging, production)
    required: false
    default: unknown
  language:
    description: Project language hint (e.g. node|python|go|java)
    required: false
    default: unknown
  test_command:
    description: Command to execute tests
    required: false
    default: ''
  lint_command:
    description: Command to execute lints
    required: false
    default: ''
  max_iterations:
    description: Max fix iterations
    required: false
    default: '1'
  pr_base:
    description: Base branch for PR to be create
    required: false
    default: 'main'
  pr_branch:
    description: Optional branch name to commit to; if omitted, a new branch is generated per run
    required: false
    default: ''

outputs:
  summary:
    description: Markdown summary of what the agent did
    value: ${{ steps.summarize.outputs.summary }}
  branch_name:
    description: Suggested branch name for the PR
    value: ${{ steps.summarize.outputs.branch_name }}

runs:
  using: composite
  steps:
    - name: Install node
      uses: actions/setup-node@v4
      with:
        node-version: '22'
        check-latest: true

    - name: Install Codex CLI and Rollbar MCP
      shell: bash
      run: |
        npm i -g @openai/codex@0.31.0
        npm i -g @rollbar/mcp-server

    - name: Write Codex config
      shell: bash
      env:
        ROLLBAR_ACCESS_TOKEN: ${{ inputs.rollbar_access_token }}
      run: |
        set -euo pipefail
        mkdir -p ~/.codex

        # Write the static portion of config.toml without a heredoc
        printf '%s\n' \
          '[profiles.ci]' \
          'approval-policy = "never"' \
          'sandbox_mode = "workspace-write"' \
          'model = "gpt-5"' \
          'cd = "."' \
          '' \
          '[mcp_servers.rollbar]' \
          'command = "npx"' \
          'args = ["-y", "@rollbar/mcp-server"]' \
          > ~/.codex/config.toml

        # Append the env table with the secret
        {
          echo
          echo '[mcp_servers.rollbar.env]'
          printf 'ROLLBAR_ACCESS_TOKEN = "%s"\n' "$ROLLBAR_ACCESS_TOKEN"
        } >> ~/.codex/config.toml

        # Optional: show config with secret redacted
        sed -e 's/ROLLBAR_ACCESS_TOKEN = ".*"/ROLLBAR_ACCESS_TOKEN = "***"/' ~/.codex/config.toml

        # Mark the GH workspace as trusted so Codex can auto-apply diffs here
        # (path is the absolute checkout path in Actions)
        {
          echo
          echo "[projects.\"$GITHUB_WORKSPACE\"]"
          echo "trust_level = \"trusted\""
        } >> ~/.codex/config.toml

    - name: Collect PR conversation (optional)
      if: ${{ inputs.collect_review_feedback == 'true' }}
      id: collect_pr
      uses: actions/github-script@v7
      env:
        TRUNCATE: ${{ inputs.review_feedback_truncate }}
        MAX_CHARS: ${{ inputs.review_feedback_max_chars }}
      with:
        github-token: ${{ inputs.github_token != '' && inputs.github_token || github.token }}
        script: |
          const fs = require('fs');
          const {owner, repo} = context.repo;

          let pr = context.payload.pull_request || null;
          let pr_number = pr?.number || null;
          let headRef = pr?.head?.ref || process.env.GITHUB_HEAD_REF || process.env.GITHUB_REF_NAME || '';
          if (!pr_number && context.payload.issue && context.payload.issue.pull_request) {
            pr_number = context.payload.issue.number;
            const got = await github.rest.pulls.get({ owner, repo, pull_number: pr_number });
            pr = got.data;
            headRef = pr?.head?.ref || headRef;
          }
          if (!pr_number && headRef) {
            const res = await github.rest.pulls.list({ owner, repo, state: 'open', per_page: 100 });
            const matches = res.data.filter(p => p.head && p.head.ref === headRef);
            if (matches.length > 0) {
              matches.sort((a,b)=> new Date(b.updated_at) - new Date(a.updated_at));
              pr = matches[0];
              pr_number = pr.number;
            }
          }

          if (!pr_number) {
            core.setOutput('review_feedback', '');
            core.setOutput('pr_number', '');
            core.setOutput('pr_head_ref', headRef || '');
            return;
          }

          const [issueComments, reviews, reviewComments] = await Promise.all([
            github.paginate(github.rest.issues.listComments, {owner, repo, issue_number: pr_number, per_page: 100}),
            github.paginate(github.rest.pulls.listReviews, {owner, repo, pull_number: pr_number, per_page: 100}),
            github.paginate(github.rest.pulls.listReviewComments, {owner, repo, pull_number: pr_number, per_page: 100}),
          ]);

          const events = [];
          for (const c of issueComments) {
            events.push({ type: 'pr_comment', author: c.user?.login || 'unknown', created_at: c.created_at, body: c.body || '' });
          }
          for (const r of reviews) {
            events.push({ type: 'review', author: r.user?.login || 'unknown', created_at: r.submitted_at || r.created_at, state: r.state, body: r.body || '' });
          }
          for (const rc of reviewComments) {
            events.push({ type: 'inline_comment', author: rc.user?.login || 'unknown', created_at: rc.created_at, path: rc.path, line: rc.original_line ?? rc.line ?? null, body: rc.body || '' });
          }
          events.sort((a,b)=> new Date(a.created_at) - new Date(b.created_at));

          const header = '=== PR CONVERSATION START ===\n';
          const footer = '\n=== PR CONVERSATION END ===\n';
          const lines = [header];
          for (const e of events) {
            if (e.type === 'pr_comment') {
              lines.push(`PR comment by @${e.author} at ${e.created_at}`);
              lines.push('');
              lines.push(e.body);
            } else if (e.type === 'review') {
              lines.push(`Review by @${e.author} at ${e.created_at} — state: ${e.state}`);
              if ((e.body||'').trim()) { lines.push(''); lines.push(e.body); }
            } else if (e.type === 'inline_comment') {
              const loc = e.line ? `${e.path}:${e.line}` : e.path;
              lines.push(`Inline comment by @${e.author} at ${e.created_at} — file: ${loc}`);
              lines.push('');
              lines.push(e.body);
            }
            lines.push('\n---\n');
          }
          lines.push(footer);
          let content = lines.join('\n');

          const doTruncate = String(process.env.TRUNCATE || 'true').toLowerCase() === 'true';
          const maxChars = Math.max(4000, parseInt(process.env.MAX_CHARS || '60000', 10) || 60000);
          if (doTruncate && content.length > maxChars) {
            const over = content.length - maxChars;
            const note = `NOTE: Conversation truncated to last ${maxChars} chars (total ${content.length}; removed ${over}).\n\n`;
            const tail = content.slice(content.length - maxChars);
            content = header + note + tail.replace(header, '');
            if (!content.endsWith(footer)) content += footer;
          }
          const outPath = `${process.env.GITHUB_WORKSPACE}/_review_feedback.md`;
          fs.writeFileSync(outPath, content, 'utf8');
          core.setOutput('review_feedback', content);
          core.setOutput('review_feedback_path', outPath);
          core.setOutput('pr_number', String(pr_number));
          core.setOutput('pr_head_ref', pr?.head?.ref || headRef || '');

    - name: Resolve effective inputs
      id: resolve
      shell: bash
      env:
        INPUT_ITEM_COUNTER: ${{ inputs.item_counter }}
        INPUT_REVIEW_FEEDBACK: ${{ inputs.review_feedback }}
        COLLECTED_REVIEW_FEEDBACK: ${{ steps.collect_pr.outputs.review_feedback }}
        INPUT_PR_BRANCH: ${{ inputs.pr_branch }}
        COLLECTED_PR_BRANCH: ${{ steps.collect_pr.outputs.pr_head_ref }}
        COLLECTED_PR_NUMBER: ${{ steps.collect_pr.outputs.pr_number }}
      run: |
        set -euo pipefail
        # Determine effective PR branch
        pr_branch_effective="${INPUT_PR_BRANCH:-}"
        if [ -z "$pr_branch_effective" ] && [ -n "${COLLECTED_PR_NUMBER:-}" ] && [ -n "${COLLECTED_PR_BRANCH:-}" ]; then
          pr_branch_effective="$COLLECTED_PR_BRANCH"
        fi
        echo "PR_BRANCH_EFFECTIVE=$pr_branch_effective" >> "$GITHUB_ENV"

        # Determine effective review feedback
        review_feedback_effective="${INPUT_REVIEW_FEEDBACK:-}"
        if [ -z "$review_feedback_effective" ] && [ -n "${COLLECTED_REVIEW_FEEDBACK:-}" ]; then
          review_feedback_effective="$COLLECTED_REVIEW_FEEDBACK"
        fi
        if [ -n "$review_feedback_effective" ]; then
          printf '%s' "$review_feedback_effective" > _review_feedback.effective.md || true
        fi
        echo "REVIEW_FEEDBACK_EFFECTIVE<<EOF" >> "$GITHUB_ENV"
        echo "$review_feedback_effective" >> "$GITHUB_ENV"
        echo "EOF" >> "$GITHUB_ENV"

        # Determine effective item counter (input wins; else parse from branch name)
        item_counter_effective="${INPUT_ITEM_COUNTER:-}"
        if [ -z "$item_counter_effective" ]; then
          ref_candidate="$pr_branch_effective"
          if [ -z "$ref_candidate" ]; then
            ref_candidate="${GITHUB_HEAD_REF:-}"
          fi
          if [ -z "$ref_candidate" ]; then
            ref_candidate="${GITHUB_REF_NAME:-}"
          fi
          if [ -n "$ref_candidate" ]; then
            parsed=$(printf '%s\n' "$ref_candidate" | sed -n 's#^autofix/rollbar-item-\([0-9][0-9]*\)-.*#\1#p') || true
            if [ -n "$parsed" ]; then item_counter_effective="$parsed"; fi
          fi
        fi
        if [ -z "$item_counter_effective" ]; then
          echo "::error::item_counter was not provided and could not be derived from branch name (expected pattern autofix/rollbar-item-<counter>-*)."
          exit 1
        fi
        echo "ITEM_COUNTER_EFFECTIVE=$item_counter_effective" >> "$GITHUB_ENV"

        # If triggered by PR review or issue comment and branch is not an Autofix branch, mark to skip heavy steps
        if [ "${GITHUB_EVENT_NAME:-}" = "pull_request_review" ] || [ "${GITHUB_EVENT_NAME:-}" = "issue_comment" ]; then
          if [ -n "$pr_branch_effective" ] && ! printf '%s' "$pr_branch_effective" | grep -qE '^autofix/rollbar-item-[0-9]+'; then
            echo "SHOULD_SKIP=true" >> "$GITHUB_ENV"
            echo "SKIP_REASON=Non-autofix PR branch ($pr_branch_effective)" >> "$GITHUB_ENV"
            echo "::notice ::Autofix action skipping: $SKIP_REASON"
          fi
        fi

    - name: Comment: rerun started
      if: ${{ env.SHOULD_SKIP != 'true' && steps.collect_pr.outputs.pr_number != '' }}
      uses: actions/github-script@v7
      env:
        PR_NUMBER: ${{ steps.collect_pr.outputs.pr_number }}
        ITEM_COUNTER: ${{ env.ITEM_COUNTER_EFFECTIVE }}
        REVIEW_FEEDBACK: ${{ steps.collect_pr.outputs.review_feedback }}
        RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
      with:
        github-token: ${{ inputs.github_token != '' && inputs.github_token || github.token }}
        script: |
          const {owner, repo} = context.repo;
          const pr = parseInt(process.env.PR_NUMBER, 10);
          const item = process.env.ITEM_COUNTER;
          const runUrl = process.env.RUN_URL;
          const len = (process.env.REVIEW_FEEDBACK || '').length;
          const body = [
            `Autofix rerun started for Rollbar item ${item}.`,
            `Including PR conversation (${len.toLocaleString()} chars).`,
            `Run: ${runUrl}`,
          ].join('\n\n');
          await github.rest.issues.createComment({ owner, repo, issue_number: pr, body });

    - name: Prepare prompt and template
      if: ${{ env.SHOULD_SKIP != 'true' }}
      shell: bash
      run: |
        set -euo pipefail
        # Resolve prompt template (host override first, then default in action)
        PROMPT_SRC=".github/rollbar-autofix/prompt.md"
        if [ ! -f "$PROMPT_SRC" ]; then
          PROMPT_SRC="$GITHUB_ACTION_PATH/templates/prompt.md"
        fi

        # Resolve PR template (host override first, then default in action)
        PR_TEMPLATE_SRC=".github/rollbar-autofix/pr-template.md"
        if [ ! -f "$PR_TEMPLATE_SRC" ]; then
          PR_TEMPLATE_SRC="$GITHUB_ACTION_PATH/templates/pr-template.md"
        fi

        # Basic, portable template rendering using sed token replacement
        esc() { printf '%s' "$1" | sed -e 's/[\\&/]/\\&/g'; }

        sed \
          -e "s/{{ITEM_COUNTER}}/$(esc "$ITEM_COUNTER_EFFECTIVE")/g" \
          -e "s/{{REVIEW_FEEDBACK}}/$(esc "$REVIEW_FEEDBACK_EFFECTIVE")/g" \
          -e "s/{{ENVIRONMENT}}/$(esc "${{ inputs.environment }}")/g" \
          -e "s/{{LANGUAGE}}/$(esc "${{ inputs.language }}")/g" \
          -e "s/{{TEST_COMMAND}}/$(esc "${{ inputs.test_command }}")/g" \
          -e "s/{{LINT_COMMAND}}/$(esc "${{ inputs.lint_command }}")/g" \
          -e "s/{{MAX_ITERATIONS}}/$(esc "${{ inputs.max_iterations }}")/g" \
          "$PROMPT_SRC" > .autofix_task.md

      # Export PR template path for later summarize step
    - name: Export PR template path
      if: ${{ env.SHOULD_SKIP != 'true' }}
      shell: bash
      run: |
        set -euo pipefail
        PR_TEMPLATE_SRC=".github/rollbar-autofix/pr-template.md"
        if [ ! -f "$PR_TEMPLATE_SRC" ]; then
          PR_TEMPLATE_SRC="$GITHUB_ACTION_PATH/templates/pr-template.md"
        fi
        echo "PR_TEMPLATE_SRC=$PR_TEMPLATE_SRC" >> "$GITHUB_ENV"

    - name: Run Codex AutoFix
      if: ${{ env.SHOULD_SKIP != 'true' }}
      id: codex_exec
      shell: bash
      env:
        OPENAI_API_KEY: ${{ inputs.openai_api_key }}
        TASK_FILE: .autofix_task.md
        CI: '1'
        TERM: dumb
      run: |
        set -euo pipefail
        set +e
        codex exec \
          --profile=ci \
          --sandbox workspace-write \
          -C "$GITHUB_WORKSPACE" \
          --model gpt-5 \
          --config 'model_reasoning_effort=high' \
          -- "$(cat "$TASK_FILE")" \
          2>&1 | tee codex_exec.log
        EXEC_RC=${PIPESTATUS[0]}
        set -e
        echo "+ codex exec exit code: $EXEC_RC"

        # Extract the last delimited Issue Description block (content-only)
        : > _issue_description.md
        awk '
          /^[[:space:]]*=== ISSUE DESCRIPTION START ===[[:space:]]*$/ { inblk=1; buf=""; next }
          /^[[:space:]]*=== ISSUE DESCRIPTION END ===[[:space:]]*$/   { if (inblk) { last=buf } inblk=0; next }
          { if (inblk) { buf = buf $0 ORS } }
          END { if (last) { printf "%s", last } }
        ' codex_exec.log > _issue_description.md || true
        # Remove a leading internal heading if present, and trim trailing whitespace
        if [ -s _issue_description.md ]; then
          awk 'NR==1 && $0 ~ /^### Issue Description/ { next } { print }' _issue_description.md \
            | sed -e :a -e '/^\n*$/{$d;N;ba' -e '}' > _issue_description.clean.md || true
          mv _issue_description.clean.md _issue_description.md || true
          echo "Extracted issue description section."
        else
          echo "No delimited issue description found in codex output."
        fi

        # If Codex failed, fail the step (and workflow)
        if [ "$EXEC_RC" -ne 0 ]; then
          echo "::error::codex exec failed with exit code $EXEC_RC. See codex_exec.log for details."
          exit "$EXEC_RC"
        fi

    - name: Summarize
      if: ${{ env.SHOULD_SKIP != 'true' }}
      id: summarize
      shell: bash
      run: |
        set -euo pipefail
        if [ -n "$PR_BRANCH_EFFECTIVE" ]; then
          branch_name="$PR_BRANCH_EFFECTIVE"
        elif [ -n "${{ inputs.pr_branch }}" ]; then
          branch_name="${{ inputs.pr_branch }}"
        else
          branch_name="autofix/rollbar-item-$ITEM_COUNTER_EFFECTIVE-${{ github.run_id }}"
        fi

        # Render PR body from template with placeholders + injected issue description
        : > _autofix_summary.md
        ISSUE_DESC=""
        if [ -s _issue_description.md ]; then
          ISSUE_DESC=$(cat _issue_description.md)
        fi

        # Replace placeholders using awk to support multi-line values safely
        awk \
          -v issue_desc="$ISSUE_DESC" \
          -v item_counter="$ITEM_COUNTER_EFFECTIVE" \
          -v review_feedback="$REVIEW_FEEDBACK_EFFECTIVE" \
          -v environment="${{ inputs.environment }}" \
          -v language="${{ inputs.language }}" \
          -v test_command="${{ inputs.test_command }}" \
          -v lint_command="${{ inputs.lint_command }}" \
          -v max_iterations="${{ inputs.max_iterations }}" \
          '
          BEGIN {
            # Escape characters special in awk replacement: & and \
            issue_desc_e = issue_desc; gsub(/\\/, "\\\\", issue_desc_e); gsub(/&/, "\\&", issue_desc_e);
            item_counter_e = item_counter; gsub(/\\/, "\\\\", item_counter_e); gsub(/&/, "\\&", item_counter_e);
            review_feedback_e = review_feedback; gsub(/\\/, "\\\\", review_feedback_e); gsub(/&/, "\\&", review_feedback_e);
            environment_e = environment; gsub(/\\/, "\\\\", environment_e); gsub(/&/, "\\&", environment_e);
            language_e = language; gsub(/\\/, "\\\\", language_e); gsub(/&/, "\\&", language_e);
            test_command_e = test_command; gsub(/\\/, "\\\\", test_command_e); gsub(/&/, "\\&", test_command_e);
            lint_command_e = lint_command; gsub(/\\/, "\\\\", lint_command_e); gsub(/&/, "\\&", lint_command_e);
            max_iterations_e = max_iterations; gsub(/\\/, "\\\\", max_iterations_e); gsub(/&/, "\\&", max_iterations_e);
          }
          {
            gsub(/\{\{ISSUE_DESCRIPTION\}\}/, issue_desc_e);
            gsub(/\{\{ITEM_COUNTER\}\}/, item_counter_e);
            gsub(/\{\{REVIEW_FEEDBACK\}\}/, review_feedback_e);
            gsub(/\{\{ENVIRONMENT\}\}/, environment_e);
            gsub(/\{\{LANGUAGE\}\}/, language_e);
            gsub(/\{\{TEST_COMMAND\}\}/, test_command_e);
            gsub(/\{\{LINT_COMMAND\}\}/, lint_command_e);
            gsub(/\{\{MAX_ITERATIONS\}\}/, max_iterations_e);
            print
          }
          ' "$PR_TEMPLATE_SRC" > _autofix_summary.md

        # If no issue description was found, drop the header and extra blank line
        if [ -z "$ISSUE_DESC" ]; then
          awk 'BEGIN{skip=0} {print} ' _autofix_summary.md \
            | sed '/^## Issue Description$/,/^$/d' > _autofix_summary.tmp && mv _autofix_summary.tmp _autofix_summary.md || true
        fi

        # If no reviewer feedback was provided, drop that section
        if [ -z "$REVIEW_FEEDBACK_EFFECTIVE" ]; then
          awk 'BEGIN{skip=0} {print} ' _autofix_summary.md \
            | sed '/^## Reviewer Feedback Incorporated$/,/^$/d' > _autofix_summary.tmp && mv _autofix_summary.tmp _autofix_summary.md || true
        fi

        {
          echo "branch_name=${branch_name}"
          echo "summary<<SUMMARY_END"
          cat _autofix_summary.md
          echo "SUMMARY_END"
        } >> "$GITHUB_OUTPUT"

    - name: Post-apply Lint, Test, and Diff
      if: ${{ env.SHOULD_SKIP != 'true' }}
      shell: bash
      env:
        LINT_CMD: ${{ inputs.lint_command }}
        TEST_CMD: ${{ inputs.test_command }}
      run: |
        set -euo pipefail
        : > _lint.log
        : > _test.log

        if [ -n "${LINT_CMD}" ]; then
          set +e
          bash -lc "${LINT_CMD}" > _lint.log 2>&1
          lint_rc=$?
          set -e
        else
          lint_rc=0
        fi

        if [ -n "${TEST_CMD}" ]; then
          set +e
          bash -lc "${TEST_CMD}" > _test.log 2>&1
          test_rc=$?
          set -e
        else
          test_rc=0
        fi

        # Always produce a diff artifact but do not include it in the PR body
        git diff --no-ext-diff > _diff.patch || true

    - name: Append repro script to summary
      if: ${{ env.SHOULD_SKIP != 'true' }}
      shell: bash
      run: |
        set -euo pipefail
        if [ -s scripts/autofix_repro.sh ]; then
          {
            echo ""
            echo "## Repro Script"
            echo '```bash'
            cat scripts/autofix_repro.sh
            echo '```'
          } >> _autofix_summary.md
        fi

    - name: Exclude ephemeral files from PR
      if: ${{ env.SHOULD_SKIP != 'true' }}
      shell: bash
      run: |
        set -euo pipefail
        mkdir -p .git/info
        {
          echo "/.autofix_task.md"
          echo "/_autofix_summary.md"
          echo "/_diff.patch"
          echo "/_issue_description.md"
          echo "/_lint.log"
          echo "/_test.log"
          echo "/scripts/autofix_repro.sh"
        } >> .git/info/exclude
        git rm --cached -f --ignore-unmatch .autofix_task.md _autofix_summary.md _diff.patch _issue_description.md _lint.log _test.log scripts/autofix_repro.sh || true

    - name: Create Pull Request
      id: cpr
      if: ${{ env.SHOULD_SKIP != 'true' }}
      uses: peter-evans/create-pull-request@v6
      with:
        token: ${{ inputs.github_token != '' && inputs.github_token || github.token }}
        branch: ${{ steps.summarize.outputs.branch_name }}
        title: 'Fix: Rollbar item ${{ env.ITEM_COUNTER_EFFECTIVE }}'
        body-path: _autofix_summary.md
        commit-message: 'Fix Rollbar item ${{ env.ITEM_COUNTER_EFFECTIVE }}'
        labels: autofix, experimental
        base: ${{ inputs.pr_base }}
        draft: true

    - name: Comment: rerun completed
      if: ${{ env.SHOULD_SKIP != 'true' }}
      uses: actions/github-script@v7
      env:
        PR_NUMBER_COLLECT: ${{ steps.collect_pr.outputs.pr_number }}
        PR_NUMBER_CPR: ${{ steps.cpr.outputs.pull-request-number }}
        PR_URL: ${{ steps.cpr.outputs.pull-request-url }}
        OPERATION: ${{ steps.cpr.outputs.pull-request-operation }}
        ITEM_COUNTER: ${{ env.ITEM_COUNTER_EFFECTIVE }}
        RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
      with:
        github-token: ${{ inputs.github_token != '' && inputs.github_token || github.token }}
        script: |
          const {owner, repo} = context.repo;
          const prnum = process.env.PR_NUMBER_CPR || process.env.PR_NUMBER_COLLECT || '';
          const pr = parseInt(prnum, 10);
          if (!pr) { return; }
          const url = process.env.PR_URL || '';
          const op = (process.env.OPERATION || '').toLowerCase();
          const item = process.env.ITEM_COUNTER;
          const runUrl = process.env.RUN_URL;
          const opText = op ? `operation: ${op}` : 'operation: updated';
          const lines = [
            `Autofix rerun completed for Rollbar item ${item} — ${opText}.`,
            url ? `PR: ${url}` : '',
            `Run: ${runUrl}`,
          ].filter(Boolean);
          const body = lines.join('\n\n');
          await github.rest.issues.createComment({ owner, repo, issue_number: pr, body });

    - name: Upload AutoFix Artifacts
      if: ${{ env.SHOULD_SKIP != 'true' }}
      uses: actions/upload-artifact@v4
      with:
        name: autofix-${{ env.ITEM_COUNTER_EFFECTIVE }}-artifacts
        if-no-files-found: ignore
        retention-days: 7
        path: |
          _autofix_summary.md
          _issue_description.md
          _diff.patch
          _lint.log
          _test.log
          codex_exec.log
          _mcp_err.log
          _item_raw.json
          AUTOFIX_PLAN.md
          scripts/autofix_repro.sh

    - name: Cleanup
      if: always()
      shell: bash
      run: rm -rf _autofix_summary.md _item_raw.json _mcp_err.log .autofix_mcp .mcp.json .autofix_task.md _lint.log _test.log _diff.patch codex_exec.log || true
